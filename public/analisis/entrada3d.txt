var p = 0;
var h = 0;
var stack [];
var heap [];
t0 = p + 2;	// Posicion relativa de la variable mensaje
t1 = h; 	//Posicion actual del h
heap[h] = 72;	//H
h = h + 1;
heap[h] = 111;	//o
h = h + 1;
heap[h] = 108;	//l
h = h + 1;
heap[h] = 97;	//a
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 109;	//m
h = h + 1;
heap[h] = 117;	//u
h = h + 1;
heap[h] = 110;	//n
h = h + 1;
heap[h] = 100;	//d
h = h + 1;
heap[h] = 111;	//o
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 49;	//1
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 50;	//2
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 51;	//3
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 52;	//4
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 53;	//5
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 64;	//@
h = h + 1;
heap[h] = 64;	//@
h = h + 1;
heap[h] = 64;	//@
h = h + 1;
heap[h] = 64;	//@
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 115;	//s
h = h + 1;
heap[h] = 1408491350;	// Fin de cadena
h = h + 1;
stack[t0] = t1;	// Asignandole el valor a la variable mensaje
t2 = p + 3;	// Posicion relativa de la variable a
t3 = 666 + 10;
t4 = t3 + 10;
t5 = t4 + 66.66;
stack[t2] = t5;	// Asignandole el valor a la variable a
t6 = p + 4;	// Posicion relativa de la variable d
t7 = 10 + 66.6666;
stack[t6] = t7;	// Asignandole el valor a la variable d
t8 = p + 5;	// Posicion relativa de la variable erick
t9 = h; 	//Posicion actual del h
heap[h] = 55;	//7
h = h + 1;
heap[h] = 56;	//8
h = h + 1;
heap[h] = 51;	//3
h = h + 1;
heap[h] = 51;	//3
h = h + 1;
heap[h] = 49;	//1
h = h + 1;
heap[h] = 51;	//3
h = h + 1;
heap[h] = 51;	//3
h = h + 1;
heap[h] = 57;	//9
h = h + 1;
heap[h] = 1408491350;	// Fin de cadena
h = h + 1;
t10 = h; 	//Posicion actual del h
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 101;	//e
h = h + 1;
heap[h] = 114;	//r
h = h + 1;
heap[h] = 105;	//i
h = h + 1;
heap[h] = 99;	//c
h = h + 1;
heap[h] = 107;	//k
h = h + 1;
heap[h] = 32;	// 
h = h + 1;
heap[h] = 1408491350;	// Fin de cadena
h = h + 1;
t12 = p + 6; // simulación de cambio de ambito
t13 = t12 + 1; // Direccion paso parametro cadena 1
stack[t13] = t9 ;// Pasando cadena 1
t14 = t12 + 2; // Direccion paso parametro cadena 2
stack[t14] = t10 ;// Pasando cadena 1
p = p + 6; // Cambio real de ambito
call concat ;
p = p - 6; // Cambio real de ambito
t15 = p + 6; // simulación de cambio de ambito
t16 = t15 + 0; // Direccion return
t17 = stack[t16];// valor nueva cadena
heap[h] = 1408491350; // Fin cadena nueva
h = h + 1; 
t18 = p + 2; // Posicion local mensaje
t19 = stack[t18] ; // Valor de mensaje
t20 = stack[t19] ; // Direccion en el heap
t22 = p + 6;	// Posicion relativa de la variable nombre
t23 = h; 	//Posicion actual del h
heap[h] = 69;	//E
h = h + 1;
heap[h] = 114;	//r
h = h + 1;
heap[h] = 105;	//i
h = h + 1;
heap[h] = 99;	//c
h = h + 1;
heap[h] = 107;	//k
h = h + 1;
heap[h] = 1408491350;	// Fin de cadena
h = h + 1;
stack[t22] = t23;	// Asignandole el valor a la variable nombre
t24 = p + 3; // Posicion local a
t25 = stack[t24] ; // Valor de a
t26 = p + 7; // Simulacion de cambio de ambito
t27 = t26 + 0 ; // Posicion inicio de cadena
stack[t27] = t24;// Paso por referencia del inicio de cadena
t28 = t26 + 1 ; // Posicion flag modo impresion
stack[t28] = 1 ;// Paso por referencia del inicio de cadena
p = p + 7; // Cambio real de ambito
call impresionNativa ;  // Llamando funcion
p = p - 7; // Retomar ambito
$$_clean_scope (t26 , 7 ) ;// Limpiando stack
t29 = p + 2; // Posicion local mensaje
t30 = stack[t29] ; // Valor de mensaje
t31 = stack[t30] ; // Direccion en el heap
t32 = p + 7; // Simulacion de cambio de ambito
t33 = t32 + 0 ; // Posicion inicio de cadena
stack[t33] = t30;// Paso por referencia del inicio de cadena
t34 = t32 + 1 ; // Posicion flag modo impresion
stack[t34] = 0 ;// Paso por referencia del inicio de cadena
p = p + 7; // Cambio real de ambito
call impresionNativa ;  // Llamando funcion
p = p - 7; // Retomar ambito
$$_clean_scope (t32 , 7 ) ;// Limpiando stack
t35 = p + 4; // Posicion local d
t36 = stack[t35] ; // Valor de d
t37 = p + 7; // Simulacion de cambio de ambito
t38 = t37 + 0 ; // Posicion inicio de cadena
stack[t38] = t35;// Paso por referencia del inicio de cadena
t39 = t37 + 1 ; // Posicion flag modo impresion
stack[t39] = 2 ;// Paso por referencia del inicio de cadena
p = p + 7; // Cambio real de ambito
call impresionNativa ;  // Llamando funcion
p = p - 7; // Retomar ambito
$$_clean_scope (t37 , 7 ) ;// Limpiando stack
t40 = p + 7;	// Posicion relativa de la variable flag
stack[t40] = 1;	// Asignandole el valor a la variable flag
t41 = p + 5; // Posicion local erick
t42 = stack[t41] ; // Valor de erick
t43 = stack[t42] ; // Direccion en el heap
t44 = p + 8; // Simulacion de cambio de ambito
t45 = t44 + 0 ; // Posicion inicio de cadena
stack[t45] = t42;// Paso por referencia del inicio de cadena
t46 = t44 + 1 ; // Posicion flag modo impresion
stack[t46] = 0 ;// Paso por referencia del inicio de cadena
p = p + 8; // Cambio real de ambito
call impresionNativa ;  // Llamando funcion
p = p - 8; // Retomar ambito
$$_clean_scope (t44 , 8 ) ;// Limpiando stack
proc impresionNativa begin
t47= p  + 0 ;
t48= stack[t47];
t49= p + 1 ;
t50= stack[t49];
if (t50== 0 ) goto L0;// Imprimir en modo %c caracter
goto L1;
L1: 
if (t50== 1) goto L2;// Imprimir en modo %e entero
goto L3;
L3: 
if (t50== 2 ) goto L4;// Imprimir en modod %d decimal
goto L5;// Error
L0: 
t51 = heap[t48]; 
if ( t51 != 1408491350 ) goto L6;
goto L7;
L6: 
print( "%c" ,t51 ); 
t48 = t48+ 1; 
goto L0;
L2: 
print( "%e" , t48 ); 
goto L7;
L4: 
print( "%d" , t48 ); 
goto L8;
L5:L6:L7:L8:
t52= 10 ;
print( "%c" , t52 ); 
end
//metodo 3D que concatena 2 cadenas
proc concat begin 
t53=p+1; //cadena1
t54=stack[t53]; //puntero al heap
t55=h; //nueva cadena
L9:
t56=heap[t54]; //extrayendo caracter
if(t56!=1408491350) goto L10;
goto L11;
L10:
heap[h]=t56; //almacenando caracter
h=h+1;
t54=t54+1;
goto L9;
L11:
t57=p+2; //cadena2
t58=stack[t57]; //puntero al heap
L12:
t59=heap[t58]; //extrayendo caracter
if(t59!=1408491350) goto L13;
goto L14;
L13:
heap[h]=t59; //almacenando caracter
h=h+1;
t58=t58+1;
goto L12;
L14:
heap[h]=0;
h=h+1;
t60=p+0; //return del metodo
stack[t60]=t55;
end
